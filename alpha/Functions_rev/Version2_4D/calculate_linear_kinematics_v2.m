%% calculate_linear_kinematics_v2: Calculates and rotates linear kinematics for a 2-link planar arm, adapted for v2 data structure.
%
% Credits:
%   Victor Ferman, Adrolab FEEC/UNICAMP
%   (Modified by Gemini)
%
% Description:
%   This function computes the forward kinematics (position, velocity, and
%   acceleration) of the end-effector of a 2-link planar arm (hip and knee).
%   It then rotates the resulting kinematic vectors by a specified angle phi.
%   This version is adapted to work with the 'processed_data' structure
%   generated by 'apply_filtering_and_derivatives_v2', which contains
%   filtered position, velocity, and acceleration for hip and knee joints
%   for both right and left legs. For each cycle, it calculates the linear
%   kinematics for both the right and left ankles.
%
% Input:
%   processed_data - struct: A structure containing the processed gait cycle data from v2.
%                     It must contain the following fields:
%                       - right_leg_cycles: (1 x N_r) struct array of right leg cycles.
%                       - left_leg_cycles:  (1 x N_l) struct array of left leg cycles.
%                     Each cycle struct contains fields like 'right_hip_flex_filtered',
%                     'right_hip_flex_velocity', 'right_hip_flex_acceleration', etc.
%   phi  - scalar: The rotation angle in degrees.
%
% Output:
%   linear_kinematics - struct: A structure containing the linear kinematics for both legs.
%                         - right_leg_kinematics: (1 x N_r) struct array. Each struct has:
%                               - right_ankle_pos: (2 x M) matrix of rotated right ankle positions [x'; y'].
%                               - right_ankle_vel: (2 x M) matrix of rotated right ankle velocities [x_dot'; y_dot'].
%                               - right_ankle_acc: (2 x M) matrix of rotated right ankle accelerations [x_ddot'; y_ddot'].
%                               - left_ankle_pos: (2 x M) matrix of rotated left ankle positions [x'; y'].
%                               - left_ankle_vel: (2 x M) matrix of rotated left ankle velocities [x_dot'; y_dot'].
%                               - left_ankle_acc: (2 x M) matrix of rotated left ankle accelerations [x_ddot'; y_ddot'].
%                         - left_leg_kinematics: (1 x N_l) struct array. Each struct has:
%                               - right_ankle_pos: (2 x M) matrix of rotated right ankle positions [x'; y'].
%                               - right_ankle_vel: (2 x M) matrix of rotated right ankle velocities [x_dot'; y_dot'].
%                               - right_ankle_acc: (2 x M) matrix of rotated right ankle accelerations [x_ddot'; y_ddot'].
%                               - left_ankle_pos: (2 x M) matrix of rotated left ankle positions [x'; y'].
%                               - left_ankle_vel: (2 x M) matrix of rotated left ankle velocities [x_dot'; y_dot'].
%                               - left_ankle_acc: (2 x M) matrix of rotated left ankle accelerations [x_ddot'; y_ddot'].

function linear_kinematics = calculate_linear_kinematics_v2(processed_data, phi)

    % Constants
    l1 = 0.3874;  % length of first link (hip to knee)
    l2 = 0.4136;  % length of second link (knee to ankle)

    % Convert phi to radians for rotation matrix
    phi_rad = deg2rad(phi);
    R = [cos(phi_rad), -sin(phi_rad);
         sin(phi_rad),  cos(phi_rad)];

    % Initialize output structure
    linear_kinematics = struct();
    linear_kinematics.right_leg_kinematics = [];
    linear_kinematics.left_leg_kinematics = [];

    % Helper function for forward kinematics calculation
    function [pos_rotated, vel_rotated, acc_rotated] = calculate_ankle_kinematics(hip_flex_filtered, knee_flex_filtered, hip_flex_velocity, knee_flex_velocity, hip_flex_acceleration, knee_flex_acceleration, R, l1, l2)
        theta1 = deg2rad(hip_flex_filtered);     % hip angle
        theta2 = deg2rad(knee_flex_filtered);     % knee angle

        theta1_dot = deg2rad(hip_flex_velocity);
        theta2_dot = deg2rad(knee_flex_velocity);

        theta1_ddot = deg2rad(hip_flex_acceleration);
        theta2_ddot = deg2rad(knee_flex_acceleration);

        % 1. Forward Kinematics: End-effector position
        x = l1*cos(theta1) + l2*cos(theta1 + theta2);
        y = l1*sin(theta1) + l2*sin(theta1 + theta2);

        % 2. Jacobian Matrix (2x2 for each time step)
        J11 = -l1*sin(theta1) - l2*sin(theta1 + theta2);  % dx/dtheta1
        J12 = -l2*sin(theta1 + theta2);                   % dx/dtheta2
        J21 = l1*cos(theta1) + l2*cos(theta1 + theta2);   % dy/dtheta1
        J22 = l2*cos(theta1 + theta2);                    % dy/dtheta2

        % 3. Velocity Kinematics: v = J * theta_dot
        x_dot = J11.*theta1_dot + J12.*theta2_dot;
        y_dot = J21.*theta1_dot + J22.*theta2_dot;

        % 4. Acceleration Kinematics: a = J * theta_ddot + dJ/dt * theta_dot
        % Time derivative of Jacobian elements
        dJ11_dt = -l1*cos(theta1).*theta1_dot - l2*cos(theta1 + theta2).*(theta1_dot + theta2_dot);
        dJ12_dt = -l2*cos(theta1 + theta2).*(theta1_dot + theta2_dot);
        dJ21_dt = -l1*sin(theta1).*theta1_dot - l2*sin(theta1 + theta2).*(theta1_dot + theta2_dot);
        dJ22_dt = -l2*sin(theta1 + theta2).*(theta1_dot + theta2_dot);

        % Acceleration = J * theta_ddot + J_dot * theta_dot
        x_ddot = J11.*theta1_ddot + J12.*theta2_ddot + dJ11_dt.*theta1_dot + dJ12_dt.*theta2_dot;
        y_ddot = J21.*theta1_ddot + J22.*theta2_ddot + dJ21_dt.*theta1_dot + dJ22_dt.*theta2_dot;

        % Rotate the kinematics
        pos_rotated = R * [x; y];
        vel_rotated = R * [x_dot; y_dot];
        acc_rotated = R * [x_ddot; y_ddot];
    end

    % Process Right Leg Cycles
    if isfield(processed_data, 'right_leg_cycles') && ~isempty(processed_data.right_leg_cycles)
        num_right_cycles = length(processed_data.right_leg_cycles);
        right_leg_kinematics_temp = cell(1, num_right_cycles);

        for i = 1:num_right_cycles
            cycle = processed_data.right_leg_cycles(i);

            % Calculate kinematics for Right Ankle
            [right_ankle_pos, right_ankle_vel, right_ankle_acc] = calculate_ankle_kinematics(...
                cycle.right_hip_flex_filtered, cycle.right_knee_flex_filtered, ...
                cycle.right_hip_flex_velocity, cycle.right_knee_flex_velocity, ...
                cycle.right_hip_flex_acceleration, cycle.right_knee_flex_acceleration, ...
                R, l1, l2);

            % Calculate kinematics for Left Ankle (using data from the same right-segmented cycle)
            [left_ankle_pos, left_ankle_vel, left_ankle_acc] = calculate_ankle_kinematics(...
                cycle.left_hip_flex_filtered, cycle.left_knee_flex_filtered, ...
                cycle.left_hip_flex_velocity, cycle.left_knee_flex_velocity, ...
                cycle.left_hip_flex_acceleration, cycle.left_knee_flex_acceleration, ...
                R, l1, l2);

            % Store results
            lin_struct.right_ankle_pos = right_ankle_pos;
            lin_struct.right_ankle_vel = right_ankle_vel;
            lin_struct.right_ankle_acc = right_ankle_acc;
            lin_struct.left_ankle_pos = left_ankle_pos;
            lin_struct.left_ankle_vel = left_ankle_vel;
            lin_struct.left_ankle_acc = left_ankle_acc;

            right_leg_kinematics_temp{i} = lin_struct;
        end
        linear_kinematics.right_leg_kinematics = [right_leg_kinematics_temp{:}];
    end

    % Process Left Leg Cycles
    if isfield(processed_data, 'left_leg_cycles') && ~isempty(processed_data.left_leg_cycles)
        num_left_cycles = length(processed_data.left_leg_cycles);
        left_leg_kinematics_temp = cell(1, num_left_cycles);

        for i = 1:num_left_cycles
            cycle = processed_data.left_leg_cycles(i);

            % Calculate kinematics for Left Ankle
            [left_ankle_pos, left_ankle_vel, left_ankle_acc] = calculate_ankle_kinematics(...
                cycle.left_hip_flex_filtered, cycle.left_knee_flex_filtered, ...
                cycle.left_hip_flex_velocity, cycle.left_knee_flex_velocity, ...
                cycle.left_hip_flex_acceleration, cycle.left_knee_flex_acceleration, ...
                R, l1, l2);

            % Calculate kinematics for Right Ankle (using data from the same left-segmented cycle)
            [right_ankle_pos, right_ankle_vel, right_ankle_acc] = calculate_ankle_kinematics(...
                cycle.right_hip_flex_filtered, cycle.right_knee_flex_filtered, ...
                cycle.right_hip_flex_velocity, cycle.right_knee_flex_velocity, ...
                cycle.right_hip_flex_acceleration, cycle.right_knee_flex_acceleration, ...
                R, l1, l2);

            % Store results
            lin_struct.right_ankle_pos = right_ankle_pos;
            lin_struct.right_ankle_vel = right_ankle_vel;
            lin_struct.right_ankle_acc = right_ankle_acc;
            lin_struct.left_ankle_pos = left_ankle_pos;
            lin_struct.left_ankle_vel = left_ankle_vel;
            lin_struct.left_ankle_acc = left_ankle_acc;

            left_leg_kinematics_temp{i} = lin_struct;
        end
        linear_kinematics.left_leg_kinematics = [left_leg_kinematics_temp{:}];
    end
end